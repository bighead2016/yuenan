任务系统
---------

task_api.erl        主要是协议封装和各种接口
task_XXX_mod.erl    主要是各种任务类型对应的处理
task_gm_api.erl     任务的gm处理
task_login_mod.erl  上下线时对任务进行的特殊容错处理
task_packet.erl     任务的协议
task_target_mod.erl 任务各种任务目标处理

----------
task_api是接口，然后各种处理经过task_mod来分发到不同的task_xxx_mod去处理，
这里的承担分发task_switch是由动态编译生成的，
根据不同的任务Type类型分发到不同的task_xxx_mod,
每个mod都有统一接口函数(do_accept, is_accepted, check_acceptable, reward,
remove_task, add_task),
其中xxx代表，1主线main,2分支branch,3日常daily,4军团日常guild,5官衔position
6每日everyday,
然后各种任务目标交由task_target_mod来匹配

----------
首先，任务在线上的时候是不会主动去判定任务的完成状态的，
    也就是说，这一切看上去任务好像完成了的错觉是由前端处理的。
然后，在下线的时候，每个玩家会做2件事：
  1.判定任务的完成状态，供再次上线时用；
  2.去掉静态数据，回写到数据库。
当再次上线时，任务会做几层判定，用以确保当前的任务是正常的：
  1.按任务id，判定任务的当前的数据与之前的数据是否能对得上，这个只是对非主线任务有效；
  2.按等级，判定主线任务是否正常。
    之所以要这样做，是因为现在的任务系统很依赖于主线任务本身，一旦主线任务发生异常，
    很多玩法与系统的依赖就会断了，影响很深远，需要注意。

----------
另外，关于军团任务的处理是有点特殊的。简单说来是放在那，欺骗前端。
当加入军团或者创建军团时，把掩藏了的军团环要重新发过去给前端；
当退出或解散时，需要欺骗前端，把任务删除，实际上任务还在后端这边，下次再加入军团时，再发过去。
上下线时对这部分也要处理，现在已经处理了。

----------
关于任务投放方式
1.主线任务完成后投放
2.支线只会投放支线
3.官衔任务单独处理,并非主线投放
