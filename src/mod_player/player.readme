关于玩家数据现状:
1.在线时，玩家的数据放在2个地方：1个是ets_player_online,这个是每秒钟定时刷上去的；
   另外1个是在玩家逻辑进程中#player{}。
2.离线时，玩家的数据也是放在2个地方：1个是在ets_player_offline,这个是在玩家下线时将ets_player_online中的#player_first{}刷上去的。
    另个1个是写到库里面了。
    之所以放一个在线副本在ets中，是为了处理两类问题：1st,玩家在线下时，有可能会被动发起战斗，这种是很坑爹的；
    2nd,玩家下线了但实际上的交互还没有结束，这点是因为无知的策划造成的。
    玩家数据的读取一般都是通过player_api:get_player_first/1这种方式读取的。他查询数据的路径是：ets_player_online->ets_player_offline->db
3.玩家上下线流程实际上并不复杂，就是出错的点比较多而已。
  1.player_login_api:login_init/2这个处理了所有上线数据刷新操作，所有会影响到玩家上线的#player{}的操作，理论上都应该在此处理处理。
  2.player_login_api:login_packets/1这个是上线后直接把该打包的数据打包起来发给前端，这样收请求包的数量就大幅减少。
  3.player_login_api:logout/1玩家下线时写库前处理的函数，一旦报错，会直接影响到回写，造成所谓的"回档"，所以听到“回档”基本上第1时间去看下logout是最明智的选择。
4.玩家下线后，有可能会有某种操作直接影响到玩家，但此时的玩家已经没有进程了，这种处理现在缓冲起来，放到db中，回头上线时，再重新计算。
    player_offline_api